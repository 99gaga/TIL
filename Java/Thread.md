# 스레드(Thread)

### 스레드란?

> 하나의 작업을 위해 OS로 부터 자원을 할당받아 동작하는 프로그램을 프로세스라고 한다. JVM은 자바로 작성된 코드를 실행시키는 하나의 프로세스이다. 이 하나의 프로세스 안에서 여러개의 쓰레드들이 프로세스에 할당된 자원을 공유하며 하나의 작업을 나누어 실행한다. 그렇다면, 왜 쓰레드라는 것을 만들었을까?
> 만약 하나의 작업을 동시에 수행하려고 할 때 여러 개의 프로세스를 띄워 수행을 하게 되면 운영체제마다 다르지만 32 ~ 64MB의 물리 메모리를 점유한다. 그에 반해서 쓰레드를 하나 추가하면 1MB 이내의 메모리를 점유한다. 그래서, 쓰레드를 "경량 프로세스" 라고도 부른다.
> 즉, 멀티 프로세스보다 효과적인 처리를 위해서 멀티 쓰레드가 있는 것이다.

### 쓰레드를 생성하는 방법 2가지

Runnable 인터페이스를 구현하거나 Thread 클래스를 상속받아 run()메소드를 오버라이딩 하면 추후에 스레드를 만들어 시작하면 만들어진 스레드가 run()안에 있는 코드를 수행하게 된다.

1. Runnable 인터페이스 구현

```java
    public class Test implements Runnable {

        @Override
        public void run() {

        }
    }
```

2. Thread 클래스 상속

```java
    public class Test extends Thread {

        @Override
        public void run() {

        }
    }
```

##### 왜 2가지 방법을 제공할까?

- 일단 Thread는 Runnable 인터페이스를 구현한 클래스이다. 그래서 쓰레드 클래스가 다른 클래스를 확장할 필요가 있을 때에는 Runnable 인터페이스를 구현하면 되고 그렇지 않은 경우에는 Thread 클래스를 상속하는 편이 편하다.

##### 스레드의 우선순위 (feat.동시성과 병 렬성)

- 자바에서 멀티 스레드는 `동시성`과 `병렬성`으로 실행된다. `동시성`은 멀티 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 성질이고, `병렬성`은 멀티 작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 성질을 말한다. 만약 4 코어인데 4개의 스레드가 병렬성으로 실행될 수도 있기 때문에 성능에 영향이 미미하다.

- JVM의 스레드 스케줄러에 의해서 스레드의 상태를 관리하고 어떤 스레드를 실행해야 할지 결정한다. 스레드 스케줄러는 사전에 실행된 스레드들의 순서로 결정하는것이 아니라, 우선 순위 및 대기 시간에 의해 결정하므로 결과는 매번 달라진다.<br>

##### 스레드의 상태

`start()` 메소드를 호출하면 곧바로 스레드가 실행되는 것처럼 보이지만 실은 실행 대기 상태이다. `run()` 메소드를 모두 끝마칠때까지 실행과 실행대기 상태를 반복하다 종료하게 된다. 하지만 실행을 하다 일시 정지 상태로 갈 수 있는데 일시정지 상태로 가면 다시 실행 대기 상태로만 가게 된다.<BR>
`NEW` : 스레드객체만 생성한 상태, `RUNNABLE`: 실행 대기상태로 실행으로 갈 수 있다.<BR>
`WAITING`: 다른 스레드가 통지할 때까지 기다리는 상태, `TIMED_WAITING`: 주어진 시간동안 기다리는 상태<BR>
`BLOCKED` 사용하고자 하는 객체의 락이 풀릴 때 까지 기다리는 상태, `TERMINATED`: 실행을 끝마친 상태

### 데몬 스레드란?

스레드가 실행중일 때는 프로그램이 끝나지 않고 기다렸다가 모든 스레드가 끝나야 프로그램이 종료될 수 있다. 하지만 데몬 스레드는 해당 스레드가 종료되지 않아도 다른 실행중인 일반 스레드가 없다면 프로그램이 종료될 수 있다.

##### 왜 데몬스레드가 존재할까?

- 예를 들어 모니터링 하는 스레드를 별도로 띄워 모니터링하다가, 주요 스레드가 종료되면 관련된 모니터링 스레드가 종료되어야 프로세스가 종료될 수 있다. 이런 부가적인 작업을 수행하는 스레드를 선언할 때 이와같은 데몬스레드로 만든다면 모니터링 스레드에 상관없이 프로세스를 종료할 수 있다.

##### 데몬스레드로 만드는 방법

- 스레드를 시작하기 전에 해당 스레드에 thread.setDaemon(true) 메소드를 사용하여 데몬스레드로 만들어줘야 한다.
- 스레드를 시작한 후에는 데몬스레드로 선언할 수 없다

### 스레드에 안전하게 synchronized

객체는 힙 영역에 만들어지고 스레드들은 힙 영역을 공유하게 된다. 그러다 보면 여러 스레드가 한 객체에 선언된 메소드에 접근하여 데이터를 처리하려고 할 때 동시에 연산을 수행하여 값이 꼬이는 경우가 발생할 수 있다. 그 때 필요한 것이 synchronized 이다.

- synchronized를 쓰는 경우는 여러 스레드가 하나에 객체를 참조하여 인스턴스 변수의 값을 바꾸게 될때 사용한다. 그러면 synchronized는 스레드를 요청 순서대로 메소드를 수행하게 보장한다.

##### synchronized 사용방법 2가지

1. 메소드 자체를 synchronized로 선언하는 방법

```java
    public synchronized void test(int value) {
        instanceValue += value;
    }
```

2. 메소드 내의 특정 문장만 syncronized로 감싸는 방법

```java
    Object one = new Object();
    public void test(int value) {
        synchronized(one) {
            instanceValue += value;
        }
    }
```

- 두 방법의 차이점은 메소드 전체를 synchronized 로 만든 것과 인스턴스 변수가 바뀌는 부분만을 synchronized블럭으로 감싼 차이가 있다

하지만 메소드 자체를 synchronized로 만들게 되면 비효율적일 수 있다. 왜냐하면 인스턴스 변수에 접근하는 코드가 한줄인데 메소드가 30줄이라면 한줄을 위해 30줄을 모두 스레드들이 기다리게 된다. 그러므로 인스턴스 변수가 변경되는 부분만 synchronized 블럭으로 처리하는것이 효율적일 것이다.

##### 메소드 내의 특정 문장만 syncronized로 감싸는 방법

- synchronized()블럭으로 감싸게 되는데 인자로 하나의 어떠한 객체든 넘기면 된다. 그러면 그 객체를 통해서 스레드가 하나씩 참조하여 수행하게 된다. 그래서 그 객체를 문지기라고도 볼 수 있다.<br>
  this를 사용하면 this의 동기화 메소드와 변수를 사용하지 못한다.
  ex) synchronized(this) {...}

- 서로 다른 인스턴스 변수를 변경하게 된다면 객체를 2개 생성해서 서로 다른 synchronized 블럭으로 감싸게 된다면 더 효율적으로 작업을 수행할 수 있다.
